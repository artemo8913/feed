/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin';
import { CacheFirst } from 'workbox-strategies';
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { registerRoute } from 'workbox-routing';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

const manifest = self.__WB_MANIFEST;
console.log(manifest);

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(
    manifest.filter((entry) =>
        typeof entry === 'string' ? entry.indexOf('.txt') === -1 : entry.url.indexOf('.txt') === -1
    )
);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        debugger;
        if (request.mode !== 'navigate') {
            return false;
        }

        console.log(url.pathname);

        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith('/_') || url.pathname.endsWith('pwa-ver.txt')) {
            return false;
        }

        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        }

        // Return true to signal that we want to use the handler.
        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

registerRoute(
    // new RegExp('/.*'),
    ({ url }) => {
        debugger;
        // url.origin === self.location.origin && url.pathname.endsWith('.png')
        console.log(url.pathname);
        return (
            url.pathname !== '/service-worker.js' &&
            !url.pathname.endsWith('pwa-ver.txt') &&
            !url.pathname.startsWith('/api/') &&
            !url.pathname.startsWith('/feedapi/')
        );
    },
    new CacheFirst({
        cacheName: 'max-cache',
        matchOptions: {
            ignoreVary: true
        },
        plugins: [
            new ExpirationPlugin({
                maxEntries: 500,
                maxAgeSeconds: 63072e3,
                purgeOnQuotaError: true
            }),
            new CacheableResponsePlugin({
                statuses: [0, 200]
            })
        ]
    })
);

// registration.waiting.postMessage({type: 'SKIP_WAITING'})
// This allows the web app to trigger skipWaiting via
self.addEventListener('message', (event) => {
    console.log(event.data);
    debugger;
    if (event.data && event.data.type === 'SKIP_WAITING') {
        void self.skipWaiting();
    }
});

// Any other custom service worker logic can go here.
